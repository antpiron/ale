\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename libale.info
@include version.texi
@settitle libale reference manual @value{VERSION}
@syncodeindex pg cp
@c %**end of header

@copying
This manual is for libale (version @value{VERSION}, @value{UPDATED}).

Copyright @copyright{} 2013 Anthony PIRON.
@end copying

@titlepage
@title libale reference manual
@subtitle for version @value{VERSION}, @value{UPDATED}
@author Anthony PIRON (@email{anthony.piron@@skynet.be})     
@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage
     
@c Output the table of contents at the beginning.
@contents

@ifnottex
@node Top, Introduction, (dir), (dir)
@top Short Sample
     
This manual is for libale (version @value{VERSION}, @value{UPDATED}).
@end ifnottex

@menu
* Introduction::
* Error::
* Bitset::
* Vector::
* Single linked list::
* Hash::
* Skip list::
* Siphash24::
* Daemon::
* Fileutils::
* Stringutils::
* Index::                       Complete index.
@end menu

@node Introduction, Error, Top, Top
@chapter Introduction

libale provides basic error handling, unlimited size bitset, portability layer for posix, daemon creating boiler plate code.


@node Error, Bitset, Introduction, Top
@chapter Error

The @code{<ale/error.h>} goal is to improve the uniformity of posix error handling. This is done trough a set of macro and a mechanism similar to @code{<errno.h>}.

The main stucture is

@deftp {C Struct} error_st
The fields @var{type} and @var{errnum} are both defined as int. @var{type} takes its values in @var{ERR_ERRNO}, @var{ERR_GAI},  @var{ERR_FERROR}, @var{ERR_UNDEF} and @var{ERR_CUSTOM}. @var{errnum} is user defined.
@end deftp

@defvar error
The variable define a variable (may be a macro) of type error_st.
@end defvar

The next macro is used to propagate -- bubble -- an error up in the call stack

@deffn {C Macro} ERROR_RET (@var{test},@var{val})
Bubble the error and returns @var{val} if @var{test} is true. This is equivalent to
       @example
        if (@var{test})
          return (@var{val});
       @end example
@end deffn

The following macro set @var{error.type} to the type of errors and returns a value if an error condition is met

@deffn {C Macro} ERROR_ERRNO_RET (test,val)
Set @var{error.type} to @var{ERR_ERRNO} and returns @var{val} if @var{test} is true.
@end deffn

@deffn {C Macro} ERROR_GAI_RET (test,val)

Set @var{error.type} to @var{ERR_GAI} and returns @var{val} if @var{test} is true.
@end deffn

@deffn {C Macro} ERROR_FERROR_RET (test,val)

Set @var{error.type} to @var{ERR_FERROR} and returns @var{val} if @var{test} is true.
@end deffn

@deffn {C Macro} ERROR_UNDEF_RET (test,val)

Set @var{error.type} to @var{ERR_UNDEF} and returns @var{val} if @var{test} is true. ``undef'' means unrelated to posix system error.
@end deffn

@deffn {C Macro} ERROR_CUSTOM_RET (test,err,val)

Set @var{error.type} to @var{ERR_CUSTOM} and @var{error.errnum} to @var{err} and returns @var{val} if @var{test} is true. ``custom'' means user defined error codes.
@end deffn

The following macro are used to show up an appropriate error message

@deffn {C Macro} ERROR_MSG_FMT (@var{test},@var{fmt},...)
@end deffn
@deffn {C Macro} ERROR_MSG (@var{test},@var{str})
Show up on stdout an appropriate error message prefixed with @var{str} or @code{printf}-like variable length argument format by @var{fmt} if @var{test} is true.
@end deffn

The following macro are similar but specific to certain kind of errors

@deffn {C Macro} ERROR_ERRNO_MSG_FMT (@var{test},@var{fmt},...)
@end deffn
@deffn {C Macro} ERROR_ERRNO_MSG (@var{test},@var{str})
Show up on stdout an appropriate error message prefixed with @var{str} or @code{printf}-like variable length argument format by @var{fmt} if @var{test} is true.
@end deffn

@deffn {C Macro} ERROR_GAI_MSG_FMT (@var{test},@var{fmt},...) 
@end deffn
@deffn {C Macro} ERROR_GAI_MSG (@var{test},@var{str})
Show up on stdout an appropriate error message prefixed with @var{str} or @code{printf}-like variable length argument format by @var{fmt} if @var{test} is true.
@end deffn

@deffn {C Macro} ERROR_FERROR_MSG_FMT (@var{test},@var{fmt},...)
@end deffn
@deffn {C Macro} ERROR_FERROR_MSG (@var{test},@var{str}) 
Show up on stdout an appropriate error message prefixed with @var{str} or @code{printf}-like variable length argument format by @var{fmt} if @var{test} is true.
@end deffn

@deffn {C Macro} ERROR_UNDEF_MSG_FMT (@var{test},@var{fmt},...)
@end deffn
@deffn {C Macro} ERROR_UNDEF_MSG (@var{test},@var{str})
Show up on stdout an appropriate error message prefixed with @var{str} or @code{printf}-like variable length argument format by @var{fmt} if @var{test} is true.
@end deffn

@deffn {C Macro} ERROR_CUSTOM_MSG_FMT (@var{test},@var{err},@var{fmt},...)
@end deffn
@deffn {C Macro} ERROR_CUSTOM_MSG (@var{test},@var{err},@var{str})
Show up on stdout an appropriate error message prefixed with @var{str} or @code{printf}-like variable length argument format by @var{fmt} if @var{test} is true.
@end deffn


The following macro are used to show up an appropriate error message and exits the program with a failure exit code

@deffn {C Macro} ERROR_FATAL_FMT (@var{test},@var{fmt},...)
@end deffn
@deffn {C Macro} ERROR_FATAL (@var{test},@var{str})
Exit with an appropriate error message prefixed with @var{str} or @code{printf}-like variable length argument format by @var{fmt} if @var{test} is true.
@end deffn

The following macro are similar but specific to certain kind of errors

@deffn {C Macro} ERROR_ERRNO_FATAL_FMT (@var{test},@var{fmt},...)
@end deffn
@deffn {C Macro} ERROR_ERRNO_FATAL (@var{test},@var{str})
Exit with an appropriate error message prefixed with @var{str} or @code{printf}-like variable length argument format by @var{fmt} if @var{test} is true.
@end deffn

@deffn {C Macro} ERROR_GAI_FATAL_FMT (@var{test},@var{fmt},...) 
@end deffn
@deffn {C Macro} ERROR_GAI_FATAL (@var{test},@var{str})
Exit with an appropriate error message prefixed with @var{str} or @code{printf}-like variable length argument format by @var{fmt} if @var{test} is true.
@end deffn

@deffn {C Macro} ERROR_FERROR_FATAL_FMT (@var{test},@var{fmt},...)
@end deffn
@deffn {C Macro} ERROR_FERROR_FATAL (@var{test},@var{str}) 
Exit with an appropriate error message prefixed with @var{str} or @code{printf}-like variable length argument format by @var{fmt} if @var{test} is true.
@end deffn

@deffn {C Macro} ERROR_UNDEF_FATAL_FMT (@var{test},@var{fmt},...)
@end deffn
@deffn {C Macro} ERROR_UNDEF_FATAL (@var{test},@var{str})
Exit with an appropriate error message prefixed with @var{str} or @code{printf}-like variable length argument format by @var{fmt} if @var{test} is true.
@end deffn

@deffn {C Macro} ERROR_CUSTOM_FATAL_FMT (@var{test},@var{err},@var{fmt},...)
@end deffn
@deffn {C Macro} ERROR_CUSTOM_FATAL (@var{test},@var{err},@var{str})
Exit with an appropriate error message prefixed with @var{str} or @code{printf}-like variable length argument format by @var{fmt} if @var{test} is true.
@end deffn


The following macro are used to send the error to the logging facility

@deffn {C Macro} ERROR_LOG_FMT (@var{test},@var{level},@var{fmt},...)
@end deffn
@deffn {C Macro} ERROR_LOG (@var{test},@var{level},@var{str})
Sends to the logging facility an appropriate error message prefixed with @var{str} or @code{printf}-like variable length argument format by @var{fmt} if @var{test} is true. The log entry is sent @code{syslog(...)} with the level @var{level}.
@end deffn

@node Bitset, Daemon, Error, Top
@chapter Bitset

@example

#include <ale/bitset.h>

int
main(int argc, char *argv[ ]) 
@{
  struct bitset bs;

  bitset_init(&bs, 1024);
  bitset_free(bs);

  return EXIT_SUCCESS;
@}


@end example

@deftypefn {C Function} {static inline int} @
           bitset_init (struct bitset *@var{bs}, size_t @var{n})

Initialise the bitset @var{bs} to zero (unset) with a maximal size of @var{n} bits. Return -1 on error and set error_errno accordingly.
@end deftypefn

@deftypefn {C Function} {static inline void} @
           bitset_free (struct bitset @var{bs})

Desallocate @var{bs}.
@end deftypefn

@deftypefn {C Function} {static inline void} @
           bitset_reset (struct bitset @var{bs})

Reset the bitset @var{bs}.
@end deftypefn

@deftypefn {C Function} {static inline void} @
           bitset_set (struct bitset @var{bs}, size_t @var{index})

Set the bit at position @var{index} of the bitset @var{bs}.
@end deftypefn

@deftypefn {C Function} {static inline void} @
           bitset_unset (struct bitset @var{bs}, size_t @var{index})

Unset the bit at position @var{index} from the bitset @var{bs}.
@end deftypefn

@deftypefn {C Function} {static inline int} @
           bitset_isset (struct bitset @var{bs}, size_t @var{index})

Test the bit at position @var{index} from the bitset @var{bs}. Return 1 if the bit is set, 0 otherwise.
@end deftypefn

@deftypefn {C Function} {static inline int} @
           bitset_isempty (struct bitset @var{bs})

Test if the bitset @var{bs} is empty. Return 1 on emptiness, 0 otherwise.
@end deftypefn

@deftypefn {C Function} {static inline void} @
                        bitset_xor (struct bitset @var{dst}, struct bitset @var{a}, struct bitset @var{b})
Performs @var{dst} = @var{a} xor @var{b} on n bits, n being the minimum number of bits between @var{dst}, @var{a} and @var{b}.
@end deftypefn

@deftypefn {C Function} {static inline size_t} @
                        bitset_ones(struct bitset @var{bs})
Return the number of ones.
@end deftypefn

@deftypefn {C Function} {static inline void} @
           bitset_setrange (struct bitset @var{bs}, size_t @var{index}, size_t @var{len})

Set @var{len} bits from position @var{index} of the bitset @var{bs}.
@end deftypefn

@node Vector, Siphash24, Bitset, Top
@chapter Vector


This module defines arrays called vectors which grows automatically as being set. There is as for C arrays no bound checking.

@example

#include "ale/vector.h"

// Create a vector named int (first parameter) and composed of
//    integers (second parameter).
// The  type struct vector_int and functions vector_int_init,
//    vector_int_destroy, vector_int_set, vector_int_get
// are created
VECTOR_INIT(int,int)

int
main(int argc, char *argv[argc])
@{
  struct vector_int vector;
  int val;


  vector_int_init(&vector);
  vector_int_set(&vector, 1, 1);
  val = vector_int_get(&vector, 1);
  vector_int_destroy(&vector);
@}

@end example

@deffn {C Macro} VECTOR_INIT_FULL (@var{name},@var{type},@var{initsize})
Create a vector named @var{name} made of variable typed with @var{type} and with an initial allocated size @var{initsize}. The type struct vector_##@var{name} and functions vector_##@var{name}##_init, vector_##@var{name}##_destroy, vector_##@var{name}##_set, vector_##@var{name}##_get are created by this macro.
@end deffn

@deffn {C Macro} VECTOR_INIT (@var{name},@var{type})
Equivalent to @code{VECTOR_INIT_FULL(name,type,VECTOR_DEFAULT_SIZE)}.
@end deffn

@deftypefn {C Function} {static inline int} @
                        vector_##name##_init (struct vector_##name *@var{vector})
Initialize the structure. Return 0 on success. May kill the current process if unable to allocate memory.
@end deftypefn

@deftypefn {C Function} {static inline void} @
                        vector_##name##_destroy (struct vector_##name *@var{vector})
Destroy the structure.
@end deftypefn

@deftypefn {C Function} {static inline void} @
                        vector_##name##_set (struct vector_##name *@var{vector}, size_t @var{pos}, type @var{value})
Set the element at position @var{pos} with the value @var{value}.
@end deftypefn

@deftypefn {C Function} {static inline type} @
                        vector_##name##_get (struct vector_##name *@var{vector}, size_t @var{pos})
Return the element at position @var{pos}.
@end deftypefn

@node Single linked list, Hash, Vector, Top
@chapter Single linked list

This module provides a single linked list. A dummy element is in front of the list. The main structure is

@example
struct sl_node
@{
   void* data;
   struct sl_node *next;
@};
@end example

@deftypefn {C Function} int @
                        sl_init (struct sl_node *@var{node});
Initialize a single linked list.
@end deftypefn

@deftypefn {C Function} int @
                        sl_destroy (struct sl_node *@var{node});
Destroy the list without freeing the data.
@end deftypefn

@deftypefn {C Function} int @
                        sl_destroy_full (struct sl_node *@var{node}, void (*@var{destroy_data})(void *));
Destroy the list calling @var{destroy_data} to free each data.
@end deftypefn

@deftypefn {C Function} int @
                        sl_insert (struct sl_node *@var{node}, size_t @var{pos}, void *@var{data});
Insert @var{data} at position @var{pos}. Return -1 on error, otherwise 0.
@end deftypefn

@deftypefn {C Function} {void*} @
                        sl_remove (struct sl_node *@var{node}, size_t @var{pos});
Remove the element at position @var{pos}. Return the data or @code{NULL} if no data.
@end deftypefn


@deftypefn {C Function} {struct sl_node*} @
                        sl_first (struct sl_node *@var{node});
Return the first element of the list, skipping the dummy element.
@end deftypefn

@deftypefn {C Function} struct sl_node* @
                        sl_next (struct sl_node *@var{node});
Return the next element in the list.
@end deftypefn

@deftypefn {C Function} {struct sl_node*} @
                        sl_nth (struct sl_node *@var{node}, size_t @var{pos});
Return the node at position @var{pos}, skipping the dummy node.
@end deftypefn


@deftypefn {C Function} {struct sl_node*} @
                        sl_search (struct sl_node *@var{node}, void *@var{data}, int (*@var{equal})(void *a, void *b));
Search a @var{data} in the list comparing with the @var{equal} function.
@end deftypefn

@deftypefn {C Function} {struct sl_node*} @
                        sl_search_full (struct sl_node *@var{node}, void *@var{data}, @
                                        int (*@var{equal})(void *a, void *b, void *cls), @
                                        void *@var{cls});
Search a @var{data} in the list comparing with the @var{equal} function. @var{cls} is a closure data passed to the @var{equal} function.
@end deftypefn


@deftypefn {C Function} int @
                        sl_push(struct sl_node *@var{node}, void *@var{data});
Push @var{data} in front of the list. Return -1 on error otherwise 0.
@end deftypefn

@deftypefn {C Function} int @
                        sl_pop (struct sl_node *@var{node}, void **@var{data});
Pop the first element of the list in @var{data}. Return -1 if the list is empty, otherwise 0.
@end deftypefn

@deftypefn {C Function} int @
                        sl_top (struct sl_node *@var{node}, void **@var{data});
Puts the first element of the list in @var{data}. Return -1 if the list is empty, otherwise 0.
@end deftypefn



@node Hash, Siphash24, Single linked list, Top
@chapter Hash

This module provides an hash table. The default hash function is reasonably collision resistant.

@example

#include "ale/error.h"
#include "ale/hash.h"

// HASH_INIT(name, keytype, valuetype, equal_function, hash_function)
HASH_INIT(int, int, int, equal_func_int, hash_func_int)

int
main(int argc, char *argv[argc])
@{
   struct hash_int hash;
   int ret, val, key;
  
   hash_int_init(&hash);

   ret = hash_int_set(&hash, 1, 1, NULL);
   ERROR_UNDEF_FATAL_FMT(0 != ret,
                         "FATAL: hash_int_set(1) returned %d\n", ret);

   ret = hash_int_get(&hash, 1, &val);
   ERROR_UNDEF_FATAL_FMT(1 != ret,
                         "FATAL: hash_int_get(1) returned %d\n", ret);

   ret = hash_int_delete(&hash, 1, &key, &val);
   ERROR_UNDEF_FATAL_FMT(1 != ret,
                         "FATAL: hash_int_delete(1) returned %d\n", ret);

   return EXIT_SUCCESS;
@}

@end example

@deftypefn {C Function} {static inline int} @
                        equal_func_int (int @var{a}, int @var{b})
Return 1 if @var{a} and @var{b} are equal, return 0 otherwise.
@end deftypefn            

@deffn {C Macro} HASH_INIT (@var{name},@var{keytype},@var{valuetype},@var{equal_func},@var{hash_func})
Create a hash table named @var{name}. @var{keytype} and @var{valuetype} respectively are the types of the keys and the values. The structure @code{struct hash_##name} is created by this macro.
@end deffn

@deftypefn {C Function} void @
                        hash_##name##_init (struct hash_##name *@var{hash})
Initialize the @var{hash} structure.
@end deftypefn

@deftypefn {C Function} void @
                        hash_##name##_init_size (struct hash_##name *@var{hash}, size_t @var{size})
Initialize the @var{hash} structure with a size @var{size}.
@end deftypefn

@deftypefn {C Function} void @
                        hash_##name##_destroy (struct hash_##name *@var{hash});
Destroy the hash without taking care of any cleaning.
@end deftypefn

@deftypefn {C Function} void @
                        hash_##name##_destroy_full (struct hash_##name *@var{hash}, @
                        void (*@var{destroy_key_func})(keytype), void (*@var{destroy_value_func})(valuetype))
Destroy the hash using the cleaning function @var{destroy_key_func} and @var{destroy_value_func} for respectively destroying the keys and the values.
@end deftypefn

@deftypefn {C Function} int @
                        hash_##name_get (struct hash_##name *@var{hash}, keytype @var{key}, valuetype *@var{value})
Gets the value of the @var{key} and saves it in @var{key}. Return 1 if the key exists, return 0 otherwise.
@end deftypefn

@deftypefn {C Function} int @
                        hash_set (struct hash *@var{hash}, keytype @var{key}, valuetype @var{value}, valuetype *@var{oldvalue})
Set the value at @var{key} to @var{value}. If an element already exists and @var{oldvalue} is not @code{NULL}, @var{oldvalue} is set with the previous value. Return 0 if no element was present, otherwise 1 (@var{kv} is set). Return -1 on an - improbable - error.
@end deftypefn

@deftypefn {C Function} int @
                        hash_delete (struct hash *@var{hash}, keytype @var{key}, valuetype @var{value}, valuetype *@var{oldvalue})
Remove element at @var{key} and set @var{oldvalue} with element if not @code{NULL}. Return 0 if element does not exist and 0 on success.
@end deftypefn


@c ========================================================
@node Skip list, Siphash24, Hash, Top
@chapter Skip list

This module provides a list structure augmented for fast search, insertion, and deletion (based on @indicateurl{ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf}).

@example
#include <stdlib.h>
#include <stdio.h>

#include "ale/error.h"
#include "ale/skiplist.h"

static inline int
cmp_int(int a, int b)
@{
  return a - b;
@}

SKL_INIT(int,16,int,int,cmp_int)

int
main(int argc, char *argv[argc])
@{
  struct skl_int skl;
  struct skl_int_node *node;
  int key, val, ret;

  skl_int_init(&skl);
  
  ret = skl_int_insert(&skl, 1, 1, NULL);
  ERROR_UNDEF_FATAL_FMT(ret != 0,
                        "FATAL: skl_int_insert(1) ret == %d != 0\n",
                        ret);
  
  ret = skl_int_search(&skl,1,&node);
  ERROR_UNDEF_FATAL_FMT(1 != ret, "FATAL: skl_int_search(1) %d != 1\n",
                        ret);
  printf("Key: %d  value: %d\n", node->key, node->value);

  ret = skl_int_delete(&skl,1,&key,&val);
  ERROR_UNDEF_FATAL_FMT(1 != ret,
                        "FATAL: skl_int_delete(1) ret == %d != 1\n",
                        ret);

  skl_int_destroy(&skl);  

  return EXIT_SUCCESS;
@}  
@end example


@deffn {C Macro} SKL_INIT (@var{name},@var{maxlevel},@var{keytype},@var{valuetype},@var{cmp_func})
Create a skip list named @var{name} with a maximum level @var{maxlevel} (< 64, values between 16 and 32 probably are reasonable for most application).  @var{keytype} and @var{valuetype} respectively are the types of the keys and the values. The types struct skl_##@var{name} and struct skl_##@var{name}##_node are created by this macro. The later is defined by

@example
struct skl_##name##_node
@{
    keytype key;
    valuetype value;
    struct skl_##name##_node *forward[maxlevel];
@};
@end example

The functions skl_##@var{name}##_init, skl_##@var{name}##_destroy, skl_##@var{name}##_destroy_full, skl_##@var{name}##_search, skl_##@var{name}##_insert and skl_##@var{name}##_delete are created by this macro.
@end deffn

@deftypefn {C Function} {static inline void} @
                        skl_##name##_init (struct skl_##name *@var{skl})
Initialise the skip list.
@end deftypefn

@deftypefn {C Function} {static inline void} @
                        skl_##name##_destroy (struct skl_##name *@var{skl})
Destroy the skip list without taking care of the keys and values.
@end deftypefn

@deftypefn {C Function} {static inline void} @
                        skl_##name##_destroy_full (struct skl_##name *@var{skl}, @
                        void (*@var{destroy_key_func})(keytype key), @
                        void (*@var{destroy_value_func})(valuetype value))
Destroy the skip list applying @var{destroy_key_func} on the keys and @var{destroy_value_func} on the values.
@end deftypefn

@deftypefn {C Function} {static inline int} @
                        skl_##name##_search (struct skl_##name *@var{skl}, keytype @var{key}, struct skl_##name##_node **@var{node})
Search for the element identified by @var{key} and set @var{node} (if not @code{NULL}) to this element if found, otherwise set to the previous element (be aware that this can be the dummy first element). Return 1 if found, 0 otherwise.
@end deftypefn

@deftypefn {C Function} {static inline int} @
                        skl_##name##_insert (struct skl_##name *@var{skl}, keytype @var{key}, @
		        valuetype @var{value}, valuetype *@var{oldvalue})
Insert the @var{value} at position @var{key} and set @var{oldvalue} to the previous value if existent. Returns 1 if a previous value was present, other 0.
@end deftypefn

@deftypefn {C Function}  {static inline int} @
                         skl_##name##_delete (struct skl_##name *@var{skl}, keytype @var{key}, @
                         keytype *@var{oldkey}, valuetype *@var{oldvalue})
Delete the element at position @var{key} and set @var{oldkey} and @var{oldvalue} to the values. Return 1 if key is found, otherwise 0.
@end deftypefn


@c ========================================================
@node Siphash24, Daemon, Skip list, Top
@chapter Siphash24

This module provide functions for keyed hash (taken from @indicateurl{https://131002.net/siphash/}).

@defvr {C Define} SIP_KEYLEN
The length of the key for the keyed hash.
@end defvr

@defvr {C Define} SIP_HASHLEN
The length of the hash.
@end defvr



@deftypefn {C Function} int @
                        siphash (uint8_t *@var{out}, const uint8_t *@var{in}, uint64_t @var{inlen}, const uint8_t *@var{k})
Hash the buffer @var{in} of length @var{inlen} into @var{out} (size @code{SIP_HASHLEN}) using the key @var{k} (size @code{SIP_KEYLEN}). Always return 0.
@end deftypefn


@node Daemon, Fileutils, Vector, Top
@chapter Daemon

@example

#include <ale/daemon.h>

int
main(int argc, char *argv[ ]) 
@{

  ERROR_FATAL(-1 == daemon_init("/tmp/myprog.pid"), "Unable to daemonize");
  ERROR_FATAL(-1 == drop_privileges(1000,1000), "Unable to set uid and gid");
  
  return EXIT_SUCCESS;
@}

@end example


@deftypefn {C Function} int @
                        drop_privileges (uid_t @var{uid}, gid_t @var{gid})
Drop the privileges of the current process.
@end deftypefn


@deftypefn {C Function} int @
                        daemon_init (char *@var{pidfile})
Initialize the daemon and stores the process id in the file with path @var{pidfile}.
@end deftypefn


@node Fileutils, Stringutils, Daemon, Top
@chapter Fileutils

@example

#include <ale/fileutils.h>

int
main(int argc, char *argv[ ]) 
@{
  ERROR_FATAL(-1 == mkpath("/tmp/path/path/", S_IRWXU), "Unable to mkpath()");
  ERROR_FATAL(-1 == rmpath("/tmp/","path/path"), "Unable to rmpath()");

  return EXIT_SUCCESS;
@}

@end example


@deftypefn {C Function} int @
                        rmpath (const char *@var{dname}, const char *@var{pathname})

Remove recursively the directory @var{pathname} rooted at @var{dname}. Returns 0 on success and -1 on failure.
@end deftypefn

@deftypefn {C Function} int @
                        unlink_path (const char *@var{dname}, const char *@var{pathname});
Unlink the file @var{pathname} rooted at @var{dname} and remove recursively the directory component of @var{pathname}. Returns 0 on success and -1 on failure.
@end deftypefn

@deftypefn {C Function} int @
                        mkpath (const char *@var{pathname}, mode_t @var{mode})
Create recursively the directory @var{pathname} with the mode @var{mode} as for posix function mkdir. Returns 0 on success and -1 on failure.
@end deftypefn

@deftypefn {C Function} FILE* @
                        mkpath_fopen (const char *@var{pathname}, const char *@var{mode})

Open the file @var{pathname} with mode @var{mode} as for posix fopen(). If the directory components of @var{pathname} do not exist, they are created.
@end deftypefn

@deftypefn {C Function} int @
                        csv_init(struct csv *@var{csv}, FILE *@var{file})

Initialize the @var{csv} structure with the csv input stream @var{file}. Return 0 on success. May abruptly kill the current process if unable to allocate memory.
@end deftypefn

@deftypefn {C Function} void @
                        csv_destroy(struct csv *@var{csv})

Destroy the @var{csv} structure.
@end deftypefn

@deftypefn {C Function} int @
                        csv_readline(struct csv *@var{csv}, struct vector_int *@var{vector})

Read one csv line from the @var{csv} structure and sets the @var{vector} to the fields. Return the number of fields on success. Return -1 on error, and sets accordingly the error in ale/error.h.
@end deftypefn

@node Stringutils, Index, Fileutils, Top
@chapter Stringsutils

This module defines a utilities for manipulating strings.

@deftypefn {C Function} char* @
                        strjoin (const char *@var{sep}, const char **@var{str})
@end deftypefn

@deftypefn {C Function} void @
                        strtolower (char *@var{dst}, const char *@var{src})
Set @var{dst} to a lowercase version of @var{src}.
@end deftypefn

Some primitives are provided to handle automatically growing strings.

@example
struct string
@{
  char *str;
  size_t len;
  size_t alloc_size;
@};
@end example

@defvr {C Define} STRING_DEFAULT_SIZE
The default size of the allocated string.
@end defvr

@deftypefn {C Function} int @
                        string_init (struct string *@var{string})
Initialize the string structure.
@end deftypefn
@deftypefn {C Function} int @
                        string_init_size (struct string *@var{string}, size_t @var{size})
Initialize the string structure. Pre-allocate @var{size} bytes for string->str.
@end deftypefn

@deftypefn {C Function} void @
                        string_destroy (struct string *@var{string});
Destroy the string and free memory.
@end deftypefn

@deftypefn {C Function} {struct string *} @
                        string_new (char *@var{str})
Allocate a new string structure and initialize the string to @var{str}
@end deftypefn

@deftypefn {C Function} void @
                        string_free (struct string *string)
Free the string structure.
@end deftypefn

@deftypefn {C Function} int @
                        string_set (struct string *@var{dst}, char *@var{str})
Set @var{dst} with @var{str}. A copy is taken.
@end deftypefn

@deftypefn {C Function} int @
                        string_append (struct string *@var{dst}, struct string *@var{src})
Append @var{src} to @var{dst}.
@end deftypefn

@deftypefn {C Function} int @
                        string_append_c (struct string *@var{dst}, const char *@var{src})
Append @var{src} to @var{dst}.
@end deftypefn


@node Index,  , Stringutils, Top
@unnumbered Index
     
@printindex fn
 
@bye


\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename libale.info
@include version.texi
@settitle libale reference manual @value{VERSION}
@syncodeindex pg cp
@c %**end of header

@copying
This manual is for libale (version @value{VERSION}, @value{UPDATED}).

Copyright @copyright{} 2013 Anthony PIRON.
@end copying

@titlepage
@title libale reference manual
@subtitle for version @value{VERSION}, @value{UPDATED}
@author Anthony PIRON (@email{anthony.piron@@skynet.be})     
@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage
     
@c Output the table of contents at the beginning.
@contents

@ifnottex
@node Top, Introduction, (dir), (dir)
@top Short Sample
     
This manual is for libale (version @value{VERSION}, @value{UPDATED}).
@end ifnottex

@menu
* Introduction::                
* Error::        
* Bitset::   
* Daemon::   
* Fileutils::   
* Index::                       Complete index.
@end menu

@node Introduction, Error, Top, Top
@chapter Introduction

libale provides basic error handling, unlimited size bitset, portability layer for posix, daemon creating boiler plate code.


@node Error, Bitset, Introduction, Top
@chapter Error

The @code{<ale/error.h>} goal is to improve the uniformity of posix error handling. This is done trough a set of macro and a mechanism similar to @code{<errno.h>}.

The next macro is used to propagate -- bubble -- an error up in the call stack

@deftypefn {C Macro}  ERROR_RET (@var{test},@var{val})
Bubble the error and returns @var{val} if @var{test} is true. This is equivalent to
       @example
        if (@var{test})
          return (@var{val});
       @end example
@end deftypefn

The following macro set @var{error_errno} to the type of errors @var{ERR_ERRNO}, @var{ERR_GAI},  @var{ERR_FERROR} or @var{ERR_UNDEF} and returns a value if an error condition is met

@deftypefn {C Macro} @
                     ERROR_ERRNO_RET (test,val)
Set @var{error_errno} to @var{ERR_ERRNO} and returns @var{val} if @var{test} is true.
@end deftypefn

@deftypefn {C Macro} ERROR_GAI_RET (test,val)

Set @var{error_errno} to @var{ERR_GAI} and returns @var{val} if @var{test} is true.
@end deftypefn

@deftypefn {C Macro} ERROR_FERROR_RET (test,val)

Set @var{error_errno} to @var{ERR_FERROR} and returns @var{val} if @var{test} is true.
@end deftypefn

@deftypefn {C Macro} ERROR_UNDEF_RET (test,val)

Set @var{error_errno} to @var{ERR_UNDEF} and returns @var{val} if @var{test} is true. ``undef'' means unrelated to posix system error.
@end deftypefn

The following macro are used to show up an appropriate error message and exits the program with a failure exit code

@deftypefn {C Macro} ERROR_FATAL_FMT (@var{test},@var{fmt},...)
@end deftypefn
@deftypefn {C Macro} ERROR_FATAL (@var{test},@var{str})
Exit with an appropriate error message prefixed with @var{str} or @code{printf}-like variable length argument format by @var{fmt} if @var{test} is true.
@end deftypefn

The following macro are similar but specific to certain kind of errors

@deftypefn {C Macro} ERROR_ERRNO_FATAL_FMT (@var{test},@var{fmt},...)
@end deftypefn
@deftypefn {C Macro} ERROR_ERRNO_FATAL (@var{test},@var{str})
Exit with an appropriate error message prefixed with @var{str} or @code{printf}-like variable length argument format by @var{fmt} if @var{test} is true.
@end deftypefn

@deftypefn {C Macro} ERROR_GAI_FATAL_FMT (@var{test},@var{fmt},...) 
@end deftypefn
@deftypefn {C Macro} ERROR_GAI_FATAL (@var{test},@var{str})
Exit with an appropriate error message prefixed with @var{str} or @code{printf}-like variable length argument format by @var{fmt} if @var{test} is true.
@end deftypefn

@deftypefn {C Macro} ERROR_FERROR_FATAL_FMT (@var{test},@var{fmt},...)
@end deftypefn
@deftypefn {C Macro} ERROR_FERROR_FATAL (@var{test},@var{str}) 
Exit with an appropriate error message prefixed with @var{str} or @code{printf}-like variable length argument format by @var{fmt} if @var{test} is true.
@end deftypefn

@deftypefn {C Macro} ERROR_UNDEF_FATAL_FMT (@var{test},@var{fmt},...)
@end deftypefn
@deftypefn {C Macro} ERROR_UNDEF_FATAL (@var{test},@var{str})
Exit with an appropriate error message prefixed with @var{str} or @code{printf}-like variable length argument format by @var{fmt} if @var{test} is true.
@end deftypefn


The following macro are used to send the error to the logging facility

@deftypefn {C Macro} ERROR_LOG_FMT (@var{test},@var{level},@var{fmt},...)
@end deftypefn
@deftypefn {C Macro} ERROR_LOG (@var{test},@var{level},@var{str})
Sends to the logging facility an appropriate error message prefixed with @var{str} or @code{printf}-like variable length argument format by @var{fmt} if @var{test} is true. The log entry is sent @code{syslog(...)} with the level @var{level}.
@end deftypefn

@node Bitset, Daemon, Error, Top
@chapter Bitset

@example

#include <ale/bitset.h>

int
main(int argc, char *argv[ ]) 
@{
  struct bitset bs;

  bitset_init(&bs, 1024);
  bitset_free(bs);

  return EXIT_SUCCESS;
@}

@end example

@deftypefn {C Function} static inline int @
           bitset_init (struct bitset *@var{bs}, size_t @var{n})

Initialise the bitset @var{bs} to zero (unset) with a maximal size of @var{n} bits. Return -1 on error and set error_errno accordingly.
@end deftypefn

@deftypefn {C Function} static inline void @
           bitset_free (struct bitset @var{bs})

Desallocate @var{bs}.
@end deftypefn

@deftypefn {C Function} static inline void @
           bitset_reset(struct bitset @var{bs})

Reset the bitset @var{bs}.
@end deftypefn

@deftypefn {C Function} static inline void @
           bitset_set (struct bitset @var{bs}, size_t @var{index})

Set the bit at position @var{index} of the bitset @var{bs}.
@end deftypefn

@deftypefn {C Function} static inline void @
           bitset_unset (struct bitset @var{bs}, size_t @var{index})

Unset the bit at position @var{index} from the bitset @var{bs}.
@end deftypefn

@deftypefn {C Function} static inline int @
           bitset_isset (struct bitset @var{bs}, size_t @var{index})

Test the bit at position @var{index} from the bitset @var{bs}. Return 1 if the bit is set, 0 otherwise.
@end deftypefn

@deftypefn {C Function} static inline int @
           bitset_isempty (struct bitset @var{bs})

Test if the bitset @var{bs} is empty. Return 1 on emptiness, 0 otherwise.
@end deftypefn

@deftypefn {C Function} static inline void @
           bitset_setrange (struct bitset @var{bs}, size_t @var{index}, size_t @var{len})

Set @var{len} bits from position @var{index} of the bitset @var{bs}.
@end deftypefn


@node Daemon, Fileutils, Bitset, Top
@chapter Daemon

@example

#include <ale/daemon.h>

int
main(int argc, char *argv[ ]) 
@{

  ERROR_FATAL(-1 == daemon_init("/tmp/myprog.pid"), "Unable to daemonize");
  ERROR_FATAL(-1 == drop_privileges(1000,1000), "Unable to set uid and gid");

  return EXIT_SUCCESS;
@}

@end example


@deftypefn {C Function} int @
                        drop_privileges (uid_t @var{uid}, gid_t @var{gid})
Drop the privileges of the current process.
@end deftypefn


@deftypefn {C Function} int @
                        daemon_init (char *@var{pidfile})
Initialize the daemon and stores the process id in the file with path @var{pidfile}.
@end deftypefn


@node Fileutils, Index, Daemon, Top
@chapter Fileutils

@example

#include <ale/fileutils.h>

int
main(int argc, char *argv[ ]) 
@{
  ERROR_FATAL(-1 == mkpath("/tmp/path/path/", S_IRWXU), "Unable to mkpath()");
  ERROR_FATAL(-1 == rmpath("/tmp/","path/path"), "Unable to rmpath()");

  return EXIT_SUCCESS;
@}

@end example


@deftypefn {C Function} int @
                        rmpath (const char *@var{dname}, const char *@var{pathname})

Remove recursively the directory @var{pathname} rooted at @var{dname}. Returns 0 on success and -1 on failure.
@end deftypefn

@deftypefn {C Function} int @
                        unlink_path (const char *@var{dname}, const char *@var{pathname});
Unlink the file @var{pathname} rooted at @var{dname} and remove recursively the directory component of @var{pathname}. Returns 0 on success and -1 on failure.
@end deftypefn

@deftypefn {C Function} int @
                        mkpath (const char *@var{pathname}, mode_t @var{mode});
Create recursively the directory @var{pathname} with the mode @var{mode} as for posix function mkdir. Returns 0 on success and -1 on failure.
@end deftypefn

@deftypefn {C Function} FILE* @
                        mkpath_fopen (const char *@var{pathname}, const char *@var{mode});

Open the file @var{pathname} with mode @var{mode} as for posix fopen(). If the directory components of @var{pathname} do not exist, they are created.
@end deftypefn


@node Index,  , Fileutils, Top
@unnumbered Index
     
@printindex cp
 
@bye

